/**
 * Box Shadow values from Material Shadow Interpolator
 *
 * - Existing library reference: http://bnj.bz/0F3o3Y1e1D3f
 * - Angular Material design notes here: http://bnj.bz/0b0Q1z3t3m38
 * - Reference CodePen: http://bnj.bz/1y311u0L083m
 */


/**
 * Shadow colors.
 * http://codepen.io/shyndman/pen/ojxmdY
 *
 * - UMBRA: "A conical shadow excluding all light from a given source; _specifically_: the conical
 * part of the shadow of a celestial body excluding all light from the primary source"
 * - PENUMBRA: "A space of partial illumination (as in an eclipse) between the perfect shadow on all
 * sides and the full light"
 *
 * @nuclide Shadow-Colors
 * @section Config > Shadows
 */
$KEY_UMBRA    : rgba(0, 0, 0, .2);
$KEY_PENUMBRA : rgba(0, 0, 0, .14);
$AMBIENT      : rgba(0, 0, 0, .12);


/**
 * Hand-designed reference shadow sets
 *
 * Source: http://codepen.io/shyndman/pen/ojxmdY
 *
 * @nuclide Shadow-Sets
 * @section Config > Shadows
 */
$REFERENCE_SHADOWS: (
  (elevation: 0,
    shadows: (
      (0, 0, 0, 0, $KEY_UMBRA),
      (0, 0, 0, 0, $KEY_PENUMBRA),
      (0, 0, 0, 0, $AMBIENT),
    )
  ),
  (elevation: 2,
    shadows: (
      (0, 3, 1, -2, $KEY_UMBRA),
      (0, 2, 2, 0, $KEY_PENUMBRA),
      (0, 1, 5, 0, $AMBIENT),
    )
  ),
  (elevation: 3,
    shadows: (
      (0, 3, 3, -2, $KEY_UMBRA),
      (0, 3, 4, 0, $KEY_PENUMBRA),
      (0, 1, 8, 0, $AMBIENT),
    )
  ),
  (elevation: 4,
    shadows: (
      (0, 2, 4, -1, $KEY_UMBRA),
      (0, 4, 5, 0, $KEY_PENUMBRA),
      (0, 1, 10, 0, $AMBIENT),
    )
  ),
  (elevation: 6,
    shadows: (
      (0, 3, 5, -1, $KEY_UMBRA),
      (0, 6, 10, 0, $KEY_PENUMBRA),
      (0, 1, 18, 0, $AMBIENT),
    )
  ),
  (elevation: 8,
    shadows: (
      (0, 5, 5, -3, $KEY_UMBRA),
      (0, 8, 10, 1, $KEY_PENUMBRA),
      (0, 3, 14, 2, $AMBIENT),
    )
  ),
  (elevation: 16,
    shadows: (
      (0, 8, 10, -5, $KEY_UMBRA),
      (0, 16, 24, 2, $KEY_PENUMBRA),
      (0, 6, 30, 5, $AMBIENT),
    )
  )
);


/**
 * Animation durations
 *
 * @nuclide Shadow-Animation-Durations
 * @section Config > Shadows
 */
$MIN_ANIMATION_LENGTH: 250ms;
$MAX_ANIMATION_LENGTH: 400ms;


/**
 * Material Design element elevations
 *
 * Source: http://bnj.bz/150D1u0J3u0r
 *
 * @nuclide Shadow-Elements-Map
 * @section Config > Shadows
 */
$materialElements: (
  dialog: (24),
  picker: (24),
  nav-drawer: (16),
  right-drawer: 16,
  bottom-sheet: 16,
  fab: 6 12 active,
  sub-menu-3: 11,
  sub-menu-2: 10,
  sub-menu-1: 9,
  menu: 8,
  bottom-nav-bar: 8,
  card: 2 8 hover,
  raised-button: 2 8 active,
  snackbar: 6,
  app-bar: 4,
  refresh-indicator: 3,
  quick-entry: 2 3 active,
  search-bar: 2 3 active,
  switch: 1
);


/**
 * @private Returns the two reference shadows whose elevations bound the specified elevation
 *
 * In the case where the supplied elevation exceeds the maximum reference elevation, the last two
 * reference shadows are returned.
 *
 * @section Shadow-Functions
 * @param $elevation
 *  The elevation
 * @example
 *  $foo = _findBoundingShadowSets();
 */
@function _findBoundingShadowSets($elevation) {
  @if $elevation < 0 {
    @warn 'Elevation is less than zero';
  }

  @for $i from 1 to length($REFERENCE_SHADOWS) {
    $lower: nth($REFERENCE_SHADOWS, $i);
    $upper: nth($REFERENCE_SHADOWS, $i + 1);
    @if (map-get($lower, 'elevation') <= $elevation) and (map-get($upper, 'elevation') > $elevation) {
      @return ($lower, $upper);
    }
  }

  $lower: nth($REFERENCE_SHADOWS, length($REFERENCE_SHADOWS) - 1);
  $upper: nth($REFERENCE_SHADOWS, length($REFERENCE_SHADOWS));

  @return ($lower, $upper);
}


/**
 * @private Performs linear interpolation between values a and b
 *
 * Returns the value between a and b proportional to x (when x is between 0 and 1. When x is outside
 * this range, the return value is a linear extrapolation)
 *
 * @section Shadow-Functions
 * @param $x
 *  The proportional control
 * @param $a
 *  The starting value
 * @param $b
 *  The ending value
 * @example
 *  $foo = _lerp(.2, 3, 6);
 */
@function _lerp($x, $a, $b) {
  @return $a + $x * ($b - $a);
}


/**
 * @private Performs linear interpolation between shadows by interpolating each property individually
 *
 * Returns the value between shadow1 and shadow2 proportional to x (when x is between 0 and 1. When
 * x is outside this range, the return value is a linear extrapolation).
 *
 * @section Shadow-Functions
 * @param $x
 *  The proportional control
 * @param $shadow1
 *  The starting shadow
 * @param $shadow2
 *  The ending shadow
 * @example
 *  $foo = _calculateShadowSetAtDepth(2);
 */
@function _lerpShadow($x, $shadow1, $shadow2) {
  // Round all parameters, as shadow definitions do not support subpixels
  $newX: round(_lerp($x, nth($shadow1, 1), nth($shadow2, 1))) + 0px;
  $newY: round(_lerp($x, nth($shadow1, 2), nth($shadow2, 2))) + 0px;
  $newBlur: round(_lerp($x, nth($shadow1, 3), nth($shadow2, 3))) + 0px;
  $newSpread: round(_lerp($x, nth($shadow1, 4), nth($shadow2, 4))) + 0px;
  // No need to _lerp the shadow color
  $newColor: nth($shadow1, 5);

  @return ($newX $newY $newBlur $newSpread $newColor);
}


/**
 * @private Calculates the set of shadows at a given elevation
 *
 * @section Shadow-Functions
 * @param $elevation
 *  The desired elevation
 * @example
 *  $foo = _calculateShadowSetAtDepth(2);
 */
@function _calculateShadowSetAtDepth($elevation) {
  $bounds: _findBoundingShadowSets($elevation);
  $min: nth($bounds, 1);
  $max: nth($bounds, 2);
  $x: ($elevation - map-get($min, 'elevation')) / (map-get($max, 'elevation') - map-get($min, 'elevation'));
  $elevationShadows: ();

  @for $i from 1 to length(map-get($min, 'shadows')) + 1 {
    $newShadow: _lerpShadow($x, nth(map-get($min, 'shadows'), $i), nth(map-get($max, 'shadows'), $i));
    $elevationShadows: append($elevationShadows, $newShadow, comma);
  }

  @return $elevationShadows;
}



/**
 * @private Generates the transition for a change between 2 elevations
 *
 * The larger the elevation change the longer the animation takes
 *
 * @section Shadow-Mixins
 * @param $elevationChange
 *  The elevation change amount
 * @param $easing
 *  The easing function or name
 * @example
 *  @include _elevationTransition(dialog);
 */
@mixin _elevationTransition($elevationChange: 6, $easing: cubic-bezier(.4, 0, .2, 1)) {
  $duration: _lerp($elevationChange / 24, $MIN_ANIMATION_LENGTH, $MAX_ANIMATION_LENGTH);

  transition: box-shadow $duration $easing;
}


/**
 * Generates box-shadow and the transition for a given elevation
 *
 * - A single elevation will generate a single box-shadow set
 * - Two elevations and a state will generate a default box-shadow set and another set that is
 * activated by the state tested with :hover and :active
 *
 * @section Shadow-Mixins
 * @param $elevation1
 *  The starting elevation
 * @param $elevation2
 *  The destination elevation
 * @param $state
 *  hover, focus, active
 * @example
 *  @include elevation(2, 8, active);
 */
@mixin elevation($elevation1, $elevation2: null, $state: null) {
  @if $elevation1 == 0 {
    box-shadow: none !important;
  } @else {
    box-shadow: _calculateShadowSetAtDepth($elevation1);
  }

  @if $elevation2 != null {
    @include _elevationTransition($elevation2 -$elevation2);

    &:#{$state} {
      @if $elevation1==0 {
        box-shadow: none !important;
      } @else {
        box-shadow: _calculateShadowSetAtDepth($elevation2);
      }
    }
  }
}


/**
 * Returns box-shadow and transition properties for specific elements. See $materialElements.
 *
 * @section Shadow-Mixins
 * @param $elementName
 *  The element to add a shadow to
 * @example
 *  @include elevationElement(dialog);
 */
@mixin elevationElement($elementName) {
  $attr: map-get($materialElements, $elementName);

  @if length($attr) == 1 {
    @include elevation(nth($attr, 1));
  } @else {
    @include elevation(nth($attr, 1), nth($attr, 2), nth($attr, 3));
  }
}

